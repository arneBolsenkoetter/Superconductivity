# ~/path/to/Superconductivity/sc_pthon/src/mySC/calibration.py

# Documentation for this file's workflow:
# 1):   Obtain a function for the vapour-pressure(s) p', observed with the digital manometer, over the voltage U_p' generated by the same manometer. These values were documented manually and are noted in the strucured  array 'DruckVolt' in 'Druck_Spaunung_Korrelation.py'. In said script they were modified to include errors dp',dU_p' in the pressure(s) p' and voltage(s) U_p, respectively, and converted to SI-units. The resulting struct-array 'npDV_si' is being imported as 'npDV'
# 2.1): Fit a linear function, p'(U_p') = m*U_p' +b, to npDV['druck'] over npDV['volts']   ->  Obtain m,b
# 2.2): Compute pressure(s) p correlating to m1.U_p with p(m1.U_p) = m * m1.U_p + b;    m1 is class 'Measurement' instance of 'LHJG__Supraleitung_1.dat'
# 3):   Compute temperature(s) T with function T90 (source: https://www.bipm.org/documents/) with errors dT
# 4):   Fit Shockley-Equation, U_AB(T) = A + B*exp(-C*T), to temperature(s) T to obtain precise temperature estimator for future measurements ('LHJG__Supraleitung_2.dat' to 'LHJG__Supraleitung_15.dat')
# 4.1): Get a robust estimation for beta0 to be parsed to the odr-fit later


# --------------------------------- imports --------------------------------------------
from __future__ import annotations

import sys
import core
import numpy as np
import sympy as sp
import config as cfg
import jax.numpy as jnp
import matplotlib.pyplot as plt
import numpy.polynomial.polynomial as poly

from jax import grad, jit, vmap
from core import T_from_p_kpa, p_kpa_from_T, ITS90_STRUCT
from scipy import odr
from config import figrect
from pathlib import Path
from mypy.core import Measurement
from scipy.odr import Model, RealData, ODR
from scipy.optimize import brentq, curve_fit, minimize_scalar
from scipy.interpolate import PchipInterpolator
from sc_data.Druck_Spaunung_Korrelation import npDV_si as npDV


# ------------------------------- macro data -------------------------------------------
this_file_path = Path(__file__).resolve()
print(cfg.user_stripped(this_file_path))
this_file_name = this_file_path.stem
print(this_file_name)


# ------------------ fitting U_p linearly to the pressure p with ODR -------------------
def linear_p_from_Up(
    m:float, dm:float, b:float, db:float, covar:float,
    Up:np.ndarray, Up_err:np.ndarray|None=None,
    psd_fix:bool=True, floor:float=0.0
) -> tuple[np.ndarray, np.ndarray]:
    """
    Propagate p = m*Up + b with uncertainties.

    var(p)_model = [Up, 1] @ [[dm^2, covar], [covar, db^2]] @ [Up, 1]^T
    var(p)_meas  = (m * Up_err)^2
    """
    Up = np.asarray(Up, float)
    sU = np.asarray(Up_err if Up_err is not None else 0.0, float)

    # model covariance for (m, b)
    C = np.array([[dm**2, covar],
                  [covar, db**2]], dtype=float)

    if psd_fix:
        # Project to PSD to remove tiny negative eigenvalues
        w, V = np.linalg.eigh(C)
        w = np.clip(w, 0.0, None)
        C = (V * w) @ V.T  # V @ diag(w) @ V.T

    # quadratic form J C J^T
    J = np.vstack([Up, np.ones_like(Up)]).T  # shape (N,2)
    var_model = np.einsum('ni,ij,nj->n', J, C, J)

    # input-measurement contribution
    var_meas = (m * sU)**2

    var_p = var_model + var_meas
    # numeric guard: never let variance be negative
    if floor is not None:
        var_p = np.maximum(var_p, floor)

    return m*Up+b, np.sqrt(var_p)


# --------------------------------- ITS90 functions ------------------------------------
TABLEIII = cfg.attrmap({# available at https://www.bipm.org/documents/20126/41791796/ITS-90.pdf/b85c434b-16be-4ff1-f8fc-0c93027452d4?version=1.3&t=1593077509109&download=true
    'HE3':      {# 0.65K to 3.2K
        'A0':       1.053477,
        'Ai':       [.980106,.676380,.372692,.151656,-.002263,.006596,.088966,-.004770,-.054943],
        'B':        7.3,
        'C':        4.3,
        'valid_t':  [0.65,3.2],
        'valid_p':  [0.050*1e3,32.01*1e3],
    },
    'HE4_sf':   {# 1.25K to 2.1768K
        'A0':       1.392408,
        'Ai':       [.527153,.166756,.050988,.026514,.001975,-.017976,.005409,.013259,.0,],
        'B':        5.6,
        'C':        2.9,
        'valid_t':  [1.25,2.18],
        'valid_p':  [0.115*1e3,5.082*1e3],
    },
    'HE4_nf':   {# 2.1768K to 5.0K
        'A0':       3.146631,
        'Ai':       [1.357655,.413923,.091159,.016349,.001826,-.004325,-.004973,.0,.0],
        'B':        10.3,
        'C':        1.9,
        'valid_t':  [2.17,5.00],
        'valid_p':  [4.958*1e3,209.97*1e3],
    }
})

def T90(
    p:jnp.ndarray,
    a0:float, ai:jnp.ndarray, b:float, c:float,
    units:str|None='Pa', checkmate:bool=False,
) -> jnp.ndarray:
    """
        !!! 
        CAUTION: Only valid for the range of 1.25K to 2.1768K and 2.1768K to 5.0K!
        !!!

        Official documentation:    https://its-90.com/definitions/!
        Computes the temperatures T90 for (an array of) pressures p. 

            T90  =  A0 + Î£[Ai*(ln(p)-B)/C]^i (i=1,i=15)

        Parameters:
        p:      jnp.ndarray((N,),float),        1D array of pressures
        a0:     float,                          some parameter, apparently on the its-90 website, but couldn't find it
        ai:     jnp.ndarray((m,),float),        1D array of parameters for the sum over i
        b:      float,                          the same applys as for a0
        c:      float,                          -"-
        units:  string='bar'|'Pa'|'kPa'|'hPa',  units of the pressures parsed hereto T90(p,...)

        Returns:
        T90:    jnp.ndarray((N,),float),         temperatures corresponding to parsed pressures

        P.S.:   First make sure you have converted your pressures to [Pa], then simply set the flag 'HaveUcheckedtheUnitQuestionmark'=True
        P.P.S:  Unit conversions:
            1bar = 100000Pa <-> 1Pa = 1e-5 bar
            1hPa = 10000Pa  <-> 1Pa = 1e-4 hPa
            1kPa = 1000Pa   <-> 1Pa = 13-3 kPa
    """
    if not checkmate:   raise ValueError("The pressure parsed to HE4_T90_over_vapour_pressure might have the wrong unit.\nCheck out this function's doc-string (<function>.__doc__) AND its definition to see how you can avoid this captcha.")
    if      units=='bar':   p = jnp.asarray(p,float)*1e5
    elif    units=='hPa':   p = jnp.asarray(p,float)*1e4
    elif    units=='kPa':   p = jnp.asarray(p,float)*1e3
    elif    units=='Pa':    p = jnp.asarray(p,float)
    else:   raise ValueError("ValueError - 'units' must be one of:   'bar' | 'hPa' | 'kPa' | 'Pa'.")
    return jnp.vectorize(lambda pp: T90jax(pp,a0,ai,b,c))(p)

def T90jax(
    p:jnp.ndarray,
    a0: float, ai:jnp.ndarray, b:float, c:float,
)   -> jnp.ndarray:
    """
        jax.numpy definition for the Temperature dependency of the pressure.
    """
    p = jnp.asarray(p,float)
    ai = jnp.asarray(ai,float)
    x = (jnp.log(p)-b)/c
    coeffs = jnp.concatenate([ai[::-1],jnp.array([a0])])
    return jnp.polyval(coeffs,x)

def dT90jax(
    p:jnp.ndarray,  dp:jnp.ndarray,
    a0:float, ai:jnp.ndarray, b:float, c:float,
)   -> jnp.ndarray:
    derivative = jit(grad(T90jax,argnums=0))
    sigmas = jnp.vectorize(lambda pp: derivative(pp,a0,ai,b,c))(p)
    return sigmas*dp

def dT90(
    p:jnp.ndarray, dp:jnp.ndarray,
    a0:float, ai:jnp.ndarray, b:float, c:float,
    units:str|None='Pa', checkmate:bool=False,
)   -> jnp.ndarray:
    if not checkmate:   raise ValueError("The pressure parsed to HE4_T90_over_vapour_pressure might have the wrong unit.\nCheck out this function's doc-string (<function>.__doc__) AND its definition to see how you can avoid this captcha.")
    if      units=='bar':   p = jnp.asarray(p,float)*1e5
    elif    units=='hPa':   p = jnp.asarray(p,float)*1e4
    elif    units=='kPa':   p = jnp.asarray(p,float)*1e3
    elif    units=='Pa':    p = jnp.asarray(p,float)
    else:   raise ValueError("ValueError - 'units' must be one of:   'bar' | 'hPa' | 'kPa' | 'Pa'.")
    return dT90jax(p,dp,a0,ai,b,c)


# ------------------------------ functions for odr-fit ---------------------------------
# ----- model: scalar and vectorized -----
def shockley_scalar(params, t):
    a, b, g = params
    return a + b * jnp.exp(-g * t)       # scalar t -> scalar y

@jit
def shockley(params, T):
    # Broadcasted vectorized version: T can be (n,)
    a, b, g = params
    return a + b * jnp.exp(-g * T)       # vector T -> vector y

@jit
def dshockley(params,dparams,T,dT):
    a,b,g=params
    dg_dparams = grad(shockley_scalar,argnums=0)(params,T)
    dg_dx = grad(shockley_scalar,argnums=1)(params,T)
    return jnp.sqrt((dg_dparams*dparams)**2 + (dg_dx*dT)**2)

# --- Jacobians via autodiff ---
# J_beta: dy/d[a,b,g] at each T_i  -> shape (n, 3)
@jit
def jacobian_beta(params, T):
    # grad w.r.t. params for a scalar t, then vmap over T
    g_params = grad(shockley_scalar, argnums=0)
    return vmap(g_params, in_axes=(None, 0))(params, T)

# J_x: dy/dx at each T_i            -> shape (n,)
@jit
def jacobian_x(params, T):
    g_x = grad(shockley_scalar, argnums=1)
    return vmap(g_x, in_axes=(None, 0))(params, T)

# ----- inverted shockley function -----
def inverted_scalar(params,U):
    a,b,g = params
    return -jnp.log((U-a)/b)/g

@jit
def inverted_shockley(params,U):
    a,b,g=params
    return -jnp.log((U-a)/b)/g

@jit
def inverted_jacobean_beta(params,U):
    h_params = grad(inverted_scalar,argnums=0)
    return vmap(h_params,in_axes=(None,0))(params,U)

@jit
def inverted_jacobean_x(params,U):
    h_x = grad(inverted_scalar,argnums=1)
    return vmap(h_x,in_axes=(None,0))(params,U)
# ---- Optional: SciPy ODR adapters (shapes must match ODR's expectation) -----
# ODR expects:
#   f(beta, x)       -> (n,)
#   fjacb(beta, x)   -> (m, n)  with m = number of parameters (here 3)
#   fjacd(beta, x)   -> (1, n)
def odr_f(beta, x):
    return np.asarray(shockley(jnp.asarray(beta), jnp.asarray(x)))

def odr_fjacb(beta, x):
    # our J_beta is (n,3); transpose to (3,n) for ODR
    J = jacobian_beta(jnp.asarray(beta), jnp.asarray(x))
    return np.asarray(J.T)

def odr_fjacd(beta, x):
    # our J_x is (n,); make it (1,n) for ODR
    Jx = jacobian_x(jnp.asarray(beta), jnp.asarray(x))
    return np.asarray(Jx)[None, :]


# ------------------------------------- helpers ----------------------------------------
def pltexit():
    plt.close()
    exit()


########################################################################################
########################################################################################
########################################################################################
########################################################################################
########################################################################################
########################################################################################



# --- before proceeding to execute the rest of the script, check the import of npDV ----
tester = False
if tester:
    # print(npDV['volts'])
    print(npDV)
    exit()

# ----------------------------------- mpl config ---------------------------------------
cfg.export_final=False
cfg.configure(overrides={'lines.linewidth':0.6})


# -------------------------------------------------- main workflow -----------------------------------------------------
# get parameters for fit between pressure and voltage (Druck_Spaunung_KOrrelation.py)
# --- linear fit: Pressure = m * Voltage + b (weighted by y-errors) ---
x  = npDV['volts'].astype(float)
sx = npDV['volts_err'].astype(float)
y  = npDV['druck'].astype(float)
sy = npDV['druck_err'].astype(float)

# keep only finite points
mask =  np.isfinite(x) & np.isfinite(y) & np.isfinite(sy) & (sy > 0)
x, sx, y, sy = x[mask], sx[mask], y[mask], sy[mask]

# Weighted least squares with NumPy (weights = 1/sigma_y)
# global m,b,var_m,m_err,var_b,b_err,covar,varco
(m, b), cov = np.polyfit(x, y, deg=1, w=1.0/sy, cov=True)

odr_res =   core.odr_line(x,y,sx,sy)
xx =        np.linspace(x.min(),x.max(),512)
pp,spp =    core.odr_prediction_band(xx,odr_res['m'],odr_res['b'],odr_res['cov'])

odr_inv = core.odr_line(y,x,sy,sx)
yy=np.linspace(y.min(),y.max(),512)
vv,svv=core.odr_prediction_band(yy,odr_inv['m'],odr_inv['b'],odr_inv['cov'])

var_m = cov[0,0]
var_b = cov[1,1]
covar = cov[0,1]
varco = cov[1,0]
m_err, b_err = np.sqrt(np.diag(cov))

# for export:
slope =     m
slope_var = var_m
slope_err = m_err
offset =    b
offset_var = var_b
offset_err = b_err


# --------------------------- get pressure p_p from Up ---------------------------------
m1 = Measurement.from_npz(cfg.DATA_DIR/"clean/LHJG__Supraleitung_1.npz")
print(m1.columns)

# ----- 1) Get temperature-pressure correlation from the ITS90.csv -----
T_tab_K   = ITS90_STRUCT['T_K'].astype(float)
p_tab_kPa = ITS90_STRUCT['p_kPa'].astype(float)     # ITS90.csv is in kPa -> conversion:
                                                    # 1 bar = 100000 Pa
                                                    # kPa -> bar  : multiply by 0.01
                                                    # bar -> kPa  : multiply by 100.0
p_tab_bar = p_tab_kPa * 0.01
# ----- 2) compute pressures according to linear fit -----
p,dp = linear_p_from_Up(
    Up=m1.u_p,Up_err=m1.u_p_err,
    m=odr_res['m'],dm=odr_res['sm'],
    b=odr_res['b'],db=odr_res['sb'],
    covar=odr_res['cov'][0,1],
)

# --- defining mask so interpolation doesn't look outside the table ---
tab_mask = (p>=p_tab_bar.min())&(p<=p_tab_bar.max())
U = m1.u_ab[tab_mask];  dU = m1.u_ab_err[tab_mask]
p = p[tab_mask];        dp = dp[tab_mask]
# --- separating mask for super- and normal-fluid ---
sf_mask = (p<5.207*1e-2)
nf_mask = (p>4.836*1e-2)
both = sf_mask&nf_mask
sf_only = sf_mask & ~both
nf_only = nf_mask & ~both
# --- applying the masks ---
p_sf = p[sf_mask];  dp_sf = dp[sf_mask]
p_nf = p[nf_mask];  dp_nf = dp[nf_mask]
U_sf = U[sf_mask];  dU_sf = dU[sf_mask]
U_nf = U[nf_mask];  dU_nf = dU[nf_mask]

# ----- 3) Compute Temperatures -----
Tnf_full = np.empty_like(p);    dTnf_full = np.empty_like(dp)
Tnf_full[nf_mask] = T90(p_nf, TABLEIII.HE4_nf.A0, TABLEIII.HE4_nf.Ai, TABLEIII.HE4_nf.B, TABLEIII.HE4_nf.C, units='bar', checkmate=True);   dTnf_full[nf_mask] = dT90(p_nf, dp_nf, TABLEIII.HE4_nf.A0, TABLEIII.HE4_nf.Ai, TABLEIII.HE4_nf.B, TABLEIII.HE4_nf.C, units='bar', checkmate=True)
# Tnf_full[nf_mask] = TUAB(U_nf,m,b, TABLEIII.HE4_nf.A0, TABLEIII.HE4_nf.Ai, TABLEIII.HE4_nf.B, TABLEIII.HE4_nf.C); dTnf_full[nf_mask] = dTUAB(U_nf,dU_nf,m,m_err,b,b_err, TABLEIII.HE4_nf.A0, TABLEIII.HE4_nf.Ai, TABLEIII.HE4_nf.B, TABLEIII.HE4_nf.C)

Tsf_full = np.empty_like(p);    dTsf_full = np.empty_like(dp)
Tsf_full[sf_mask] = T90(p_sf, TABLEIII.HE4_sf.A0, TABLEIII.HE4_sf.Ai, TABLEIII.HE4_sf.B, TABLEIII.HE4_sf.C, units='bar', checkmate=True);   dTsf_full[sf_mask] = dT90(p_sf, dp_sf, TABLEIII.HE4_sf.A0, TABLEIII.HE4_sf.Ai, TABLEIII.HE4_sf.B, TABLEIII.HE4_sf.C, units='bar', checkmate=True)
# Tsf_full[sf_mask] = TUAB(U_sf,m,b, TABLEIII.HE4_sf.A0, TABLEIII.HE4_sf.Ai, TABLEIII.HE4_sf.B, TABLEIII.HE4_sf.C)
# dTsf_full[sf_mask] = dTUAB(U_sf,dU_sf,m,m_err,b,b_err,TABLEIII.HE4_sf.A0, TABLEIII.HE4_sf.Ai, TABLEIII.HE4_sf.B, TABLEIII.HE4_sf.C)

# ----- 4) broadcast onto shared array -----
w_sf = np.zeros_like(p);    w_sf[sf_mask] = 1/dTsf_full[sf_mask]**2
w_nf = np.zeros_like(p);    w_nf[nf_mask] = 1/dTnf_full[nf_mask]**2
wsum = w_sf+w_nf
T = np.empty_like(p);   dT = np.empty_like(dp)
T[sf_only] = Tsf_full[sf_only];     dT[sf_only] = dTsf_full[sf_only]
T[nf_only] = Tnf_full[nf_only];     dT[nf_only] = dTnf_full[nf_only]
T[both] = (w_sf[both]*Tsf_full[both] + w_nf[both]*Tnf_full[both])/wsum[both];   dT[both] = np.sqrt(dTsf_full[both]**2 + dTnf_full[both]**2)

mask_sfit = (1.73<=T)&(T<=2.17)
mask_nfit = (T>=2.16)&(T<=4.1)
Usfit = U[mask_sfit];   dUsfit = dU[mask_sfit]
Tsfit = T[mask_sfit];   dTsfit = dT[mask_sfit]
Unfit = U[mask_nfit];   dUnfit = dU[mask_nfit]
Tnfit = T[mask_nfit];   dTnfit = dT[mask_nfit]


# -------------- 4.1) Get robust estimate for initial parameters beta0 -----------------
# IDEA: for any triplet ((x1,y1),(x2,y2),(x3,y3)) with x1<x2<x3:
# R_obs   = (y1-y2)/(y2-y3) 
#         = (a+b*exp(-g*x1) - a-b*exp(-g*x2)) / (a+b*exp(-g*x2) - a-b*exp(-g*x3))
#         = (exp(-g*x1) - exp(-g*x2)) / (exp(-g*x2) - exp(-g*x3)) \eqiv R_mod
# -> get estimate for g by minimizing |R_obs - R_mod|
# Then with fixed g:    exp(-g*x)->z, solve linear-least-squares for (a,b) from y(z) = a + b*z
def make_centered_model(T0):
    def f(beta, x):
        a, btil, c = beta
        dx = x - T0
        return a + btil * np.exp(-c * dx)

    def fjacb(beta, x):
        a, btil, c = beta
        dx = x - T0
        e = np.exp(-c * dx)
        # rows: [â/âa, â/âb~, â/âc], shape -> (3, n)
        Ja = np.ones_like(x)
        Jb = e
        Jc = -btil * dx * e
        return np.vstack([Ja, Jb, Jc])

    def fjacd(beta, x):
        a, btil, c = beta
        dx = x - T0
        e = np.exp(-c * dx)
        Jx = (-btil * c * e)[None, :]   # (1, n)
        return Jx

    return f, fjacb, fjacd

def _ratio_model(g, x1, x2, x3):
    eg1, eg2, eg3 = np.exp(-g*x1), np.exp(-g*x2), np.exp(-g*x3)
    denom = (eg2 - eg3)
    if np.abs(denom) < 1e-300:
        return np.inf
    return (eg1 - eg2) / denom

def _estimate_g_from_triple(x1, y1, x2, y2, x3, y3, g_bounds):
    # Skip degenerate cases
    denom = (y2 - y3)
    if np.abs(denom) < 1e-300:
        return np.nan
    R_obs = (y1 - y2) / denom

    def obj(g):
        R_mod = _ratio_model(g, x1, x2, x3)
        return np.abs(R_obs - R_mod)

    res = minimize_scalar(obj, bounds=g_bounds, method="bounded")
    if not res.success or not np.isfinite(res.x):
        return np.nan
    return res.x

def _pick_spread_indices(n, k):
    # choose k indices spread across [0, n-1]
    return np.unique(np.round(np.linspace(0, n-1, k)).astype(int))

# -----------------------------------------------------------------------------
def _safe_exp_neg(g, xc):
    # Keep |g*xc| within a safe window to avoid overflow/underflow.
    # 709 ~ log(np.finfo(float).max). Use a safety margin.
    LIM = 680.0
    z = np.exp(-np.clip(g * xc, -LIM, LIM))
    return z

def estimate_beta0_exp_offset(x, y, g_bounds=None, ridge=0.0):
    """
        Robust, assumption-light initializer for y = a + b*exp(-g*x)
        Returns ( [a0, btil0, g0], T0 ) with centered x (x_c = x - T0).
    """
    x = np.asarray(x, float)
    y = np.asarray(y, float)
    assert x.ndim == y.ndim == 1 and x.size == y.size and x.size >= 3

    # sort & center
    idx = np.argsort(x)
    x, y = x[idx], y[idx]
    T0 = float(np.median(x))
    xc = x - T0
    xmax = float(np.max(np.abs(xc))) if x.size else 1.0
    dx = float(np.ptp(xc)) or 1.0

    # sensible, data-driven bounds for g
    # lower: nearly flat across span; upper: avoid overflow and absurdly steep decays
    if g_bounds is None:
        g_low  = 1e-6 / dx
        g_overflow_cap = 0.5 * 709.0 / max(xmax, 1e-12)   # keep |g*xc| <= ~354
        g_high = min(1e6 / dx, g_overflow_cap)
        g_bounds = (g_low, max(g_high, g_low*10))

    # Objective: for a given g, solve a,b~ by scaled lstsq on [1, exp(-g*xc)]
    def rss_for_g(g):
        z = _safe_exp_neg(g, xc)
        Phi = np.column_stack([np.ones_like(xc), z])

        # column scaling -> better conditioning
        col_scale = np.linalg.norm(Phi, axis=0)
        col_scale[col_scale == 0] = 1.0
        Phi_s = Phi / col_scale

        try:
            if ridge > 0:
                # (Phi_s^T Phi_s + Î»I) ab_s = Phi_s^T y
                ATA = Phi_s.T @ Phi_s
                ATy = Phi_s.T @ y
                ab_s = np.linalg.solve(ATA + ridge * np.eye(2), ATy)
            else:
                ab_s, *_ = np.linalg.lstsq(Phi_s, y, rcond=None)
        except np.linalg.LinAlgError:
            # tiny ridge rescue
            ATA = Phi_s.T @ Phi_s
            ATy = Phi_s.T @ y
            ab_s = np.linalg.solve(ATA + 1e-12 * np.eye(2), ATy)

        ab = ab_s / col_scale  # unscale
        res = y - Phi @ ab
        return float(res @ res)

    # 1D bounded minimization over g
    res = minimize_scalar(rss_for_g, bounds=g_bounds, method="bounded")
    g0 = float(res.x if (res.success and np.isfinite(res.x)) else 1.0 / dx)

    # final (a0, b~0) with the chosen g0
    z0 = _safe_exp_neg(g0, xc)
    Phi0 = np.column_stack([np.ones_like(xc), z0])
    col_scale = np.linalg.norm(Phi0, axis=0)
    col_scale[col_scale == 0] = 1.0
    Phi0_s = Phi0 / col_scale
    try:
        if ridge > 0:
            ATA = Phi0_s.T @ Phi0_s
            ATy = Phi0_s.T @ y
            ab_s = np.linalg.solve(ATA + ridge * np.eye(2), ATy)
        else:
            ab_s, *_ = np.linalg.lstsq(Phi0_s, y, rcond=None)
    except np.linalg.LinAlgError:
        ATA = Phi0_s.T @ Phi0_s
        ATy = Phi0_s.T @ y
        ab_s = np.linalg.solve(ATA + 1e-12 * np.eye(2), ATy)

    a0, btil0 = (ab_s / col_scale)

    return np.array([a0, btil0, g0], float), T0

def transform_centered_params(beta_centered, cov_centered, T0):
    """
    Map (a, btil, c) -> (a, b, c) with b = btil*exp(c*T0),
    and propagate the covariance accordingly.
    """
    a, btil, c = map(float, beta_centered)
    ecT0 = np.exp(c * T0)
    b = btil * ecT0

    J = np.array([
        [1.0,      0.0,        0.0],
        [0.0,      ecT0,       T0 * b],
        [0.0,      0.0,        1.0],
    ], dtype=float)

    cov_orig = J @ cov_centered @ J.T
    sd_orig  = np.sqrt(np.diag(cov_orig))
    beta_orig = np.array([a, b, c], dtype=float)
    return beta_orig, cov_orig, sd_orig

@jit
def band_from_params_jax(beta, cov_beta_np, x_grid_np, sx_np=None):
    """
        beta:        (3,) JAX or NumPy  -> [a,b,c]
        cov_beta_np: (3,3) NumPy (from ODR)   (we'll convert to jax)
        x_grid_np:   (n,) NumPy/JAX
        sx_np:       (n,) NumPy/JAX or None  (temperature uncertainties on the grid)
        returns: y_hat (n,), s_y (n,)
    """
    beta_j = jnp.asarray(beta, float)
    C = jnp.asarray(cov_beta_np, float)
    x = jnp.asarray(x_grid_np, float)

    # predictions
    y = shockley(beta_j, x)  # (n,)

    # parameter part: diag(J C J^T)
    J = jacobian_beta(beta_j, x)  # (n,3)
    var_model = jnp.einsum('ni,ij,nj->n', J, C, J)

    # x-uncertainty (optional)
    if sx_np is not None:
        sx = jnp.asarray(sx_np, float)
        dy_dx = jacobian_x(beta_j, x)  # (n,)
        var_x = (dy_dx * sx) ** 2
        var_tot = var_model + var_x
    else:
        var_tot = var_model

    var_tot = jnp.clip(var_tot, a_min=0.0)  # numerical guard
    return y, jnp.sqrt(var_tot)

@jit
def inv_band_from_params_jax(beta, cov_beta_np, U_grid_np, sU_np=None):
    """
    beta:        (3,) JAX/NumPy  -> [a,b,c]
    cov_beta_np: (3,3) NumPy covariance
    U_grid_np:   (n,) voltages
    sU_np:       (n,) voltage uncertainties or None
    """
    beta_j = jnp.asarray(beta, float)
    C = jnp.asarray(cov_beta_np, float)
    U = jnp.asarray(U_grid_np, float)

    # Domain guard: (U-a)/b must be > 0. Clip slightly away from 0.
    a, b, c = beta_j
    z = (U - a) / b
    z = jnp.clip(z, 1e-300, None)
    # recompute U if you prefer strict consistency; here we only guard the log internally
    T = -jnp.log(z) / c  # equals inverted_shockley but avoids re-checks

    # Parameter covariance part
    Jb = inverted_jacobean_beta(beta_j, U)  # (n,3)
    var_model = jnp.einsum('ni,ij,nj->n', Jb, C, Jb)

    # U-uncertainty (optional)
    if sU_np is not None:
        sU = jnp.asarray(sU_np, float)
        dT_dU = inverted_jacobean_x(beta_j, U)  # (n,)
        var_U = (dT_dU * sU) ** 2
        var_tot = var_model + var_U
    else:
        var_tot = var_model

    var_tot = jnp.clip(var_tot, a_min=0.0)
    return T, jnp.sqrt(var_tot)
# -----------------------------------------------------------------------------
# Initial parameters (separate phases)
(sfbeta0, sfT0) = estimate_beta0_exp_offset(Tsfit, Usfit)
(nfbeta0, nfT0) = estimate_beta0_exp_offset(Tnfit, Unfit)

# Centered models
sfmodel = Model(*make_centered_model(sfT0))
nfmodel = Model(*make_centered_model(nfT0))

# Ensure you pass the correct errors (x->sx, y->sy) and avoid zeros/NaNs
eps = 1e-9
dUsfit_safe = np.where(np.isfinite(dUsfit) & (dUsfit > 0), dUsfit, eps)
dUnfit_safe = np.where(np.isfinite(dUnfit) & (dUnfit > 0), dUnfit, eps)
dTsfit_safe = np.where(np.isfinite(dTsfit) & (dTsfit > 0), dTsfit, eps)
dTnfit_safe = np.where(np.isfinite(dTnfit) & (dTnfit > 0), dTnfit, eps)

sfdata = RealData(Tsfit, Usfit, sx=dTsfit_safe, sy=dUsfit_safe)
nfdata = RealData(Tnfit, Unfit, sx=dTnfit_safe, sy=dUnfit_safe)

sfout = ODR(sfdata, sfmodel, beta0=sfbeta0).run()
nfout = ODR(nfdata, nfmodel, beta0=nfbeta0).run()

#SF
sfbetac =               sfout.beta
sfcovc =                sfout.cov_beta
sfbeta, sfcov, sfsd =   transform_centered_params(sfbetac, sfcovc, sfT0)

# NF
nfbetac =   nfout.beta
nfcovc =    nfout.cov_beta
nfbeta, nfcov, nfsd = transform_centered_params(nfbetac, nfcovc, nfT0)

print("SF beta (a,b,c):", sfbeta)
print("SF 1Ï:", sfsd)
print("NF beta (a,b,c):", nfbeta)
print("NF 1Ï:", nfsd)


if __name__=="__main__":
    initial_tests = False
    # --- some checks, from the early stages of this script ---
    if initial_tests:
        print(m)
        print(odr_res['m'])
        print(b)
        print(odr_res['b'])
        print(m_err)
        print(odr_res["sm"])
        print(b_err)
        print(odr_res['sb'])
        print(odr_res['cov'][0,1])

        show_calib=False
        if show_calib:
            calib_fig,calib_axes=plt.subplots(nrows=1,ncols=2,figsize=figrect(ncols=2))

            cal1=calib_axes[0].errorbar(x=x,xerr=sx,y=y,yerr=sy)
            calib_axes[0].plot(xx,pp,zorder=3)
            calib_axes[0].fill_between(xx,pp-spp,pp+spp,alpha=0.3,zorder=2)
            calib_axes[0].set_xlabel(rf'Voltage $U_P$ [V]')
            calib_axes[0].set_ylabel(rf'Pressure $P$ [bar]')

            cal2=calib_axes[1].errorbar(x=y,xerr=sy,y=x,yerr=sx)
            calib_axes[1].plot(yy,vv,zorder=3)
            calib_axes[1].fill_between(yy,vv-svv,vv+svv,alpha=0.3,zorder=2)
            calib_axes[1].set_ylabel(rf'Voltage $U_P$ [V]')
            calib_axes[1].set_xlabel(rf'Pressure $P$ [bar]')
            plt.show()

        print_cov = False
        if print_cov:
            label_w, val_w = 6, 24
            print('')
            print(f"{'var_m':<{label_w}}= {var_m:>{val_w}}{'':^8}"f"{'Ï_m ':>{label_w}}= {np.sqrt(var_m):>{val_w}}")
            print(f"{'var_b':<{label_w}}= {var_b:>{val_w}}{'':^8}"f"{'Ï_m ':>{label_w}}= {np.sqrt(var_b):>{val_w}}")
            print(f"{'covar':<{label_w}}= {var_b:>{val_w}}{'':^8}"f"{'Ï_c ':>{label_w}}= {np.sqrt(var_b):>{val_w}}")
            print(f"{'varco':<{label_w}}= {var_b:>{val_w}}{'':^8}"f"{'Ï_v ':>{label_w}}= {np.sqrt(var_b):>{val_w}}")
            print('')
            print(f"Fit: y = m*x + b")              # Fit: y = m*x + b
            print(f"m = {m:.6g} Â± {m_err:.2g}")     # m = 1.05119 Â± 0.0019
            print(f"b = {b:.6g} Â± {b_err:.2g}")     # b = -0.000774967 Â± 0.00013
            print(cov)

        HarryPlotter = False
        if HarryPlotter:
            fig,ax = plt.subplots(ncols=1,nrows=1,figsize=figrect())
            ax.scatter(x=npDV['volts'],y=npDV['druck'],s=1,zorder=3)
            ax.errorbar(
                x=npDV['volts'], y=npDV['druck'],
                xerr=npDV['volts_err'], yerr=npDV['druck_err'],
                fmt='none', **cfg.err_kw(),
                zorder=2
            )
            ax.set_xlabel(r"Voltage [V]")
            ax.set_ylabel(r"Pressure [bar]")
            fitboi=True
            if fitboi:
                # Optional: add fit line to your existing plot
                xx = np.linspace(x.min(), x.max(), 200)
                yy = m*xx + b
                ax.plot(
                    xx, yy,
                    lw=1.0, zorder=1, color='red',
                    label=(
                        "linear fit:\n"
                        f"m = {m:.6g} Â± {m_err:.2g}\n"
                        f"b = {b:.6g} Â± {b_err:.2g}"
                    ),
                )
                ax.legend()
                out_png = cfg.savefig(fig, "druck_vs_voltage_fitted", "png")
                out_pdf = cfg.savefig(fig, "druck_vs_voltage_fitted")
            else:
                out_png = cfg.savefig(fig, "druck_vs_voltage", "png")
                out_pdf = cfg.savefig(fig, "druck_vs_voltage")

            print('','Saved at', cfg.user_stripped(out_png), 'and', out_pdf, sep='\n')

            plt.show()
            # plt.close()

    show_pressure=False
    if show_pressure:
        pressure_fig,pressure_ax=plt.subplots(nrows=1,ncols=2,figsize=figrect(ncols=2))
        f1_bar=pressure_ax[0].errorbar(
            x=m1.u_p,xerr=m1.u_p_err,
            y=p_bar,yerr=dp_bar,
            **cfg.err_kw(),
        )
        f1=pressure_ax[1].errorbar(
            x=m1.u_p,xerr=m1.u_p_err,
            y=p,yerr=dp,
            **cfg.err_kw(elw=0.2,),
        )
        for bar in f1[2]:
            bar.set_alpha(0.3)
        pressure_ax[0].set_xlabel(r'Voltage $U_P$')
        pressure_ax[0].set_ylabel(r'Pressure $P$')
        plt.show()

    checksum=False
    if checksum:
        print(len(T))
        print(len(T[sf_only]))
        print(len(T[nf_only]))
        print(len(T[both]))
        print(f'{"Checksum:":<10}{len(T):4}=={len(T[sf_only]):>4}+{len(T[both]):4}+{len(T[nf_only]):<4}','...',bool(len(T)==len(T[sf_only])+len(T[both])+len(T[nf_only])))

    # ----- 1.1)[detour]: fit ITS90 -----
    show_c = False
    if show_c:
        cfig,cax=plt.subplots(nrows=1,ncols=1,figsize=figrect())
        c1 = cax.plot(
            p_tab_bar,T_tab_K,
            label=r'ITS90-calibration',
        )
        xx = np.linspace(p_tab_bar.min(),p_tab_bar.max(),1024)
        whole_range = True
        if whole_range:     xxHE3=xx;   xxHE4sf=xx;     xxHE4nf=xx
        else:
            xxHE3 =     np.linspace(TABLEIII.HE3.valid_p[0], TABLEIII.HE3.valid_p[1],512)*1e-2
            xxHE4sf =   np.linspace(TABLEIII.HE4_sf.valid_p[0], TABLEIII.HE4_sf.valid_p[1],512)*1e-2
            xxHE4nf =   np.linspace(TABLEIII.HE4_nf.valid_p[0], TABLEIII.HE4_nf.valid_p[1],512)*1e-2

        # yyHE3 =     T90(xxHE3, TABLEIII.HE3.A0, TABLEIII.HE3.Ai, TABLEIII.HE3.B, TABLEIII.HE3.C, units='bar', checkmate=True)
        # c2 =        cax.plot(xx,yyHE3,  label=r'$T_{90}$ for $^{3}$HE')
        yyHE4sf =   T90(xxHE4sf, TABLEIII.HE4_sf.A0, TABLEIII.HE4_sf.Ai, TABLEIII.HE4_sf.B, TABLEIII.HE4_sf.C, units='bar', checkmate=True)
        c3 =        cax.plot(xx,yyHE4sf,label=r'$T_{90}$ for $^{4}$HE - superfluid')
        yyHE4nf =   T90(xxHE4nf, TABLEIII.HE4_nf.A0, TABLEIII.HE4_nf.Ai, TABLEIII.HE4_nf.B, TABLEIII.HE4_nf.C, units='bar', checkmate=True)
        c4 =        cax.plot(xx,yyHE4nf,label=r'$T_{90}$ for $^{3}$HE - normalfluid')

        cax.set_ylim(1.0,T_tab_K.max())
        cax.set_xlabel(r'Pressure $P\quad[\mathrm{bar}]$')
        cax.set_ylabel(r'Temperature $T\quad[\mathrm{K}]$')
        cax.legend()
        plt.show()

    # --- figure of pressure p and voltage U_AB over temperature T ---
    show_d=False
    if show_d:
        dfig,dax = plt.subplots(ncols=1,nrows=1,figsize=figrect())
        dsecax = dax.twinx()
        d1 = dax.errorbar(x=Tsf,y=p_sf,yerr=dp_sf,label=r'$T_{90}$ superfluid')
        d2 = dax.errorbar(x=Tnf,y=p_nf,yerr=dp_nf,label=r'$T_{90}$ normalfluid')
        dsec1 = dsecax.errorbar(x=T,y=U,yerr=dU,label=r'Voltage $U_\mathrm{AB}$')
        # labels = [dax.get_labels(),dsexax.get_labels()]
        # handles = [dax.get_handles(),dsecax.get_handles()]
        dax.legend()
        # dax.set_xlim(2.0,2.35)
        # dax.set_ylim(0.0,0.1)
        dax.set_xlabel(r'Temperature $T\quad[\mathrm{K}]$')
        dax.set_ylabel(r'Pressure $P(U_\mathrm{P})\quad[\mathrm{bar}]$')
        dsecax.set_ylabel(r'Voltage $U_\mathrm{AB}\quad[\mathrm{V}]$')
        plt.show()
        pltexit()

    # --- figure of temperature over U_AB ---
    show_e = False
    if show_e:
        efig,eax = plt.subplots(ncols=1,nrows=1,figsize=figrect())
        e1 = eax.errorbar(x=U,xerr=dU,y=T,yerr=dT)
        eax.set_xlabel(r"Voltage [V]")
        plt.show()
        pltexit()

    plot_AB=True
    if plot_AB:
        mask_zoom = (T>=1.73)&(T<=2.2)
        utilmask = sf_mask | (T<=2.4)
        fig,ax=plt.subplots(nrows=1,ncols=2,figsize=figrect(ncols=2))

        sfxx = np.linspace(T[utilmask].min(),T[utilmask].max(),512)
        sfdxx = np.full_like(sfxx, float(np.median(dTsfit)))
        sfyy = shockley(sfbeta,sfxx)
        sfy,sfdy = np.asarray(band_from_params_jax(sfbeta,sfcov,sfxx,sx_np=sfdxx))
        finite = np.isfinite(sfxx) & np.isfinite(sfy) & np.isfinite(sfdy)
        sfxx,sfy,sfdy = sfxx[finite],sfy[finite],sfdy[finite]
        # 3) Construct bounds and make sure upper >= lower
        lower = sfy - sfdy
        upper = sfy + sfdy
        swap = upper < lower
        if np.any(swap):
            tmp = lower[swap]
            lower[swap] = upper[swap]
            upper[swap] = tmp
        xx = np.linspace(2.1,2.4,128)
        yy = shockley(nfbeta,xx)
        ax[0].errorbar(x=T[utilmask],xerr=dT[utilmask],y=U[utilmask],yerr=dU[utilmask])
        ax[0].plot(sfxx,sfyy,zorder=3)
        ax[0].fill_between(
            sfxx, lower, upper,
            alpha=0.25, lw=0, facecolor='tab:orange', zorder=2, label='1Ï band (SF)'
        )
        ax[0].plot(xx,yy,zorder=3)
        # 5) Make sure axes include the polygon
        ax[0].relim()
        ax[0].autoscale_view()
        ax[0].set_title(r'Superfuid Phase')
        ax[0].set_xlabel(r'Temperatur [K]')
        ax[0].set_ylabel(r'Spannung $U_\mathrm{AB}$')

        nfxx = np.linspace(T[nf_mask].min(),T[nf_mask].max(),512)
        nfyy = shockley(nfbeta,nfxx)
        xx2 = np.linspace(T[nf_mask].min(),2.4,128)
        yy2 = shockley(sfbeta,xx2)
        ax[1].errorbar(x=T[nf_mask],xerr=dT[nf_mask],y=U[nf_mask],yerr=dU[nf_mask])
        ax[1].plot(nfxx,nfyy,zorder=3)
        ax[1].plot(xx2,yy2,zorder=3)
        ax[1].set_title(r'Normalfluid Phase')
        ax[1].set_xlabel(r'Temperatur [K]')
        ax[1].set_ylabel(r'Spannung $U_\mathrm{AB}$')

        plt.show()

    pltexit()