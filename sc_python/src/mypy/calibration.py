# ~/path/to/Superconductivity/sc_pthon/src/mySC/calibration.py

# Documentation for this file's workflow:
# 1):   Obtain a function for the vapour-pressure(s) p', observed with the digital manometer, over the voltage U_p' generated by the same manometer. These values were documented manually and are noted in the strucured  array 'DruckVolt' in 'Druck_Spaunung_Korrelation.py'. In said script they were modified to include errors dp',dU_p' in the pressure(s) p' and voltage(s) U_p, respectively, and converted to SI-units. The resulting struct-array 'npDV_si' is being imported as 'npDV'
# 2.1): Fit a linear function, p'(U_p') = m*U_p' +b, to npDV['druck'] over npDV['volts']   ->  Obtain m,b
# 2.2): Compute pressure(s) p correlating to m1.U_p with p(m1.U_p) = m * m1.U_p + b;    m1 is class 'Measurement' instance of 'LHJG__Supraleitung_1.dat'
# 3):   Compute temperature(s) T with function T90 (source: https://www.bipm.org/documents/) with errors dT
# 4):   Fit Shockley-Equation, U_AB(T) = A + B*exp(-C*T), to temperature(s) T to obtain precise temperature estimator for future measurements ('LHJG__Supraleitung_2.dat' to 'LHJG__Supraleitung_15.dat')
# 4.1): Get a robust estimation for beta0 to be parsed to the odr-fit later


# --------------------------------- imports --------------------------------------------
from __future__ import annotations

import sys
import core
import numpy as np
import sympy as sp
import config as cfg
import jax.numpy as jnp
import matplotlib.pyplot as plt
import numpy.polynomial.polynomial as poly

from jax import grad, jit, vmap
from core import T_from_p_kpa, p_kpa_from_T, ITS90_STRUCT
from scipy import odr
from config import figrect
from pathlib import Path
from mypy.core import Measurement
from scipy.odr import Model, RealData, ODR
from scipy.optimize import brentq, curve_fit, minimize_scalar
from scipy.interpolate import PchipInterpolator
from sc_data.Druck_Spaunung_Korrelation import npDV_si as npDV


# ------------------------------- macro data -------------------------------------------
this_file_path = Path(__file__).resolve()
print(cfg.user_stripped(this_file_path))
this_file_name = this_file_path.stem
print(this_file_name)


# ------------------ fitting U_p linearly to the pressure p with ODR -------------------
def linear_p_from_Up(
    m:float, dm:float, b:float, db:float, covar:float, 
    Up:np.ndarray, Up_err:np.ndarray|None=None
) -> tuple[np.ndarray, np.ndarray] :
    """
        Linear model 
            p = m*Up + b 
        Returns: 
            (p,σ)

        with:   σ = np.sqrt(var(p)),    var(p) = (m*σU)^2 + (Up*σm)^2 + σb^2 + 2*Up*cov(m,b)
    """
    Up     = np.asarray(Up, float)
    Up_err = np.asarray(Up_err if Up_err is not None else 0.0, float)

    p =     m*Up + b
    var_p = (m*Up_err)**2 + (dm*Up)**2 + db**2 + 2*Up*covar
    dp =    np.sqrt(var_p)
    return p, dp


# --------------------------------- ITS90 functions ------------------------------------
TABLEIII = cfg.attrmap({# available at https://www.bipm.org/documents/20126/41791796/ITS-90.pdf/b85c434b-16be-4ff1-f8fc-0c93027452d4?version=1.3&t=1593077509109&download=true
    'HE3':      {# 0.65K to 3.2K
        'A0':       1.053477,
        'Ai':       [.980106,.676380,.372692,.151656,-.002263,.006596,.088966,-.004770,-.054943],
        'B':        7.3,
        'C':        4.3,
        'valid_t':  [0.65,3.2],
        'valid_p':  [0.050*1e3,32.01*1e3],
    },
    'HE4_sf':   {# 1.25K to 2.1768K
        'A0':       1.392408,
        'Ai':       [.527153,.166756,.050988,.026514,.001975,-.017976,.005409,.013259,.0,],
        'B':        5.6,
        'C':        2.9,
        'valid_t':  [1.25,2.18],
        'valid_p':  [0.115*1e3,5.082*1e3],
    },
    'HE4_nf':   {# 2.1768K to 5.0K
        'A0':       3.146631,
        'Ai':       [1.357655,.413923,.091159,.016349,.001826,-.004325,-.004973,.0,.0],
        'B':        10.3,
        'C':        1.9,
        'valid_t':  [2.17,5.00],
        'valid_p':  [4.958*1e3,209.97*1e3],
    }
})

def T90(
    p:jnp.ndarray,
    a0:float, ai:jnp.ndarray, b:float, c:float,
    units:str|None='Pa', checkmate:bool=False,
) -> jnp.ndarray:
    """
        !!! 
        CAUTION: Only valid for the range of 1.25K to 2.1768K and 2.1768K to 5.0K!
        !!!

        Official documentation:    https://its-90.com/definitions/!
        Computes the temperatures T90 for (an array of) pressures p. 

            T90  =  A0 + Σ[Ai*(ln(p)-B)/C]^i (i=1,i=15)

        Parameters:
        p:      jnp.ndarray((N,),float),        1D array of pressures
        a0:     float,                          some parameter, apparently on the its-90 website, but couldn't find it
        ai:     jnp.ndarray((m,),float),        1D array of parameters for the sum over i
        b:      float,                          the same applys as for a0
        c:      float,                          -"-
        units:  string='bar'|'Pa'|'kPa'|'hPa',  units of the pressures parsed hereto T90(p,...)

        Returns:
        T90:    jnp.ndarray((N,),float),         temperatures corresponding to parsed pressures

        P.S.:   First make sure you have converted your pressures to [Pa], then simply set the flag 'HaveUcheckedtheUnitQuestionmark'=True
        P.P.S:  Unit conversions:
            1bar = 100000Pa <-> 1Pa = 1e-5 bar
            1hPa = 10000Pa  <-> 1Pa = 1e-4 hPa
            1kPa = 1000Pa   <-> 1Pa = 13-3 kPa
    """
    if not checkmate:   raise ValueError("The pressure parsed to HE4_T90_over_vapour_pressure might have the wrong unit.\nCheck out this function's doc-string (<function>.__doc__) AND its definition to see how you can avoid this captcha.")
    if      units=='bar':   p = jnp.asarray(p,float)*1e5
    elif    units=='hPa':   p = jnp.asarray(p,float)*1e4
    elif    units=='kPa':   p = jnp.asarray(p,float)*1e3
    elif    units=='Pa':    p = jnp.asarray(p,float)
    else:   raise ValueError("ValueError - 'units' must be one of:   'bar' | 'hPa' | 'kPa' | 'Pa'.")
    return jnp.vectorize(lambda pp: T90jax(pp,a0,ai,b,c))(p)

def T90jax(
    p:jnp.ndarray,
    a0: float, ai:jnp.ndarray, b:float, c:float,
)   -> jnp.ndarray:
    """
        jax.numpy definition for the Temperature dependency of the pressure.
    """
    p = jnp.asarray(p,float)
    ai = jnp.asarray(ai,float)
    x = (jnp.log(p)-b)/c
    coeffs = jnp.concatenate([ai[::-1],jnp.array([a0])])
    return jnp.polyval(coeffs,x)

def dT90jax(
    p:jnp.ndarray,  dp:jnp.ndarray,
    a0:float, ai:jnp.ndarray, b:float, c:float,
)   -> jnp.ndarray:
    derivative = jit(grad(T90jax,argnums=0))
    sigmas = jnp.vectorize(lambda pp: derivative(pp,a0,ai,b,c))(p)
    return sigmas*dp

def dT90(
    p:jnp.ndarray, dp:jnp.ndarray,
    a0:float, ai:jnp.ndarray, b:float, c:float,
    units:str|None='Pa', checkmate:bool=False,
)   -> jnp.ndarray:
    if not checkmate:   raise ValueError("The pressure parsed to HE4_T90_over_vapour_pressure might have the wrong unit.\nCheck out this function's doc-string (<function>.__doc__) AND its definition to see how you can avoid this captcha.")
    if      units=='bar':   p = jnp.asarray(p,float)*1e5
    elif    units=='hPa':   p = jnp.asarray(p,float)*1e4
    elif    units=='kPa':   p = jnp.asarray(p,float)*1e3
    elif    units=='Pa':    p = jnp.asarray(p,float)
    else:   raise ValueError("ValueError - 'units' must be one of:   'bar' | 'hPa' | 'kPa' | 'Pa'.")
    return dT90jax(p,dp,a0,ai,b,c)

# def interp_with_grid_error(
#     xM, yM, X, dX:np.ndarray|None=None,
#     err_mode = 'max',
#     return_yerr=True,
#     ):
#     xM = np.asarray(xM,float)
#     yM = np.asarray(yM,float)
#     if xM.ndim != 1 or yM.ndim != 1 or xM.size != yM.size:
#         raise ValueError("xM and yM must be 1D arrays of the same length")
#     if xM.size < 2:
#         raise ValueError("Need at least two map points for interpolation")
#     order = np.argsort(xM)
#     xM = xM[order]; yM=yM[order]

#     X  = np.asarray(X,float)
#     mask = (X>xM.min())&(X<xM.max())
#     X = X[mask]
#     dX = dX[mask]

#     j = np.searchsorted(xM,X,side='right')
#     i = j-1

#     x0 = xM[i]
#     x1 = xM[j]
#     y0 = yM[i]
#     y1 = yM[j]

#     w = x1 - x0
#     h = y1 - y0
#     dx_left = X-x0

#     Y = y0 + dx_left/w * h
#     dy_left = Y-y0
#     dy_right = y1-Y

#     if err_mode=='max':
#         dY = np.maximum(dy_left,dy_right)
#     elif err_mode=='min':
#         dY = np.minimum(dy_left,dy_right)
#     elif err_mode=='slope' and dX is not None:
#         m = h/w
#         dY = dX*m
#     elif err_mode=='asym' and dX is not None:
#         Xmin = X-dX;    Xplu = X+dX
#         jmin = np.searchsorted(xM,Xmin,side='right');   imin=jmin-1
#         jplu = np.searchsorted(xM,Xplu,side='right');   iplu=jplu-1
#         Ymin = yM[imin] + (Xmin-xM[imin])/(xM[jmin]-xM[imin]) * (yM[jmin]-yM[imin])
#         Yplu = yM[iplu] + (Xplu-xM[iplu])/(xM[jplu]-xM[iplu]) * (yM[jplu]-yM[iplu])
#         dY = np.vstack([Y-Ymin,Yplu-Y])
#     else:
#         raise ValueError("err_mode must either be 'max', 'min', 'slope' or 'asym'.")

#     return (Y,dY) if return_yerr else (Y,None)


# # ------------------------------------- shockley ---------------------------------------
# alpha_,beta_,gamma_,T_ = sp.symbols('alpha_ beta_ gamma_ T_',real=True)
# shockley = alpha_ + beta_*sp.exp(-gamma_*T_)
# dY_dT = sp.diff(shockley,T_)
# dY_da = sp.diff(shockley,alpha_)
# dY_db = sp.diff(shockley,beta_)
# dY_dg = sp.diff(shockley,gamma_)

# Y =     sp.lambdify((alpha_,beta_,gamma_,T_),shockley,'numpy')
# dY_da = sp.lambdify((alpha_,beta_,gamma_,T_),dY_da,'numpy')
# dY_db = sp.lambdify((alpha_,beta_,gamma_,T_),dY_db,'numpy')
# dY_dg = sp.lambdify((alpha_,beta_,gamma_,T_),dY_dg,'numpy')


# ------------------------------ functions for odr-fit ---------------------------------

# def mdl_shockley(params,T,use_theta:bool=True):
#     if use_theta:   return shockley(params,T)
#     else:           return shockley_theta(params,T)

# def shockley1(params,T):
#     T = np.asarray(T,float)
#     a,b,g = params
#     return a + b*np.exp(-g*T)

# def shockley_theta(params,T):
#     T = np.asarray(T,float)
#     a,b,th = params
#     g = np.exp(theta)
#     return a +b *np.exp(-g*T)

# def mdl_jacobean_params(params,T,use_theta:bool=True):
#     if use_theta:
#         a,b,th = params
#         g = np.exp(th)
#         e = np.exp(-g*T)
#         dya = np.ones_like(T)
#         dyb = e
#         dyth = -b*T*e*g
#         return np.vstack([dya,dyb,dyth])[None,:,:]
#     else:
#         a,b,g = params 
#         e = np.exp(-g*T)
#         J = np.vstack([np.ones_like(T),e,-b*T*e])
#         return J[None,:,:]                          # odr expects shape (1,p,N)

# def mdl_jacobean_variables(params,T,use_theta:bool=True):
#     if use_theta:
#         a,b,th = params
#         g = np.exp(th)
#     else:
#         a,b,g = params
#     d = -b*g*np.exp(-g*T)
#     return d[None,None,:]

# def inv_shockley(params,U):
#     alpha,beta,gamma = params
#     return (-1)*np.log((U-alpha)/beta)/gamma

# def guess_params(X, Y, log_slope:bool=False):
#     X = np.asarray(X,float)
#     Y = np.asarray(Y, float)
#     a0 = np.percentile(Y,10)
#     b0 = max(np.median(Y)-a0,1e-12)
#     if log_slope:
#         xq = np.quantile(X, [0.2, 0.8])
#         yq = np.clip(np.quantile(Y - a0, [0.2, 0.8]), 1e-12, None)
#         g0 = abs(np.log(yq[0]/yq[1]) / (xq[1]-xq[0])) if xq[1] > xq[0] else 1.0
#     else:
#         dx = max(X.max() - X.min(), 1e-12)
#         g0 = 1.0/dx
#     return np.array([a0,b0,g0],float)

# ----- use jax.numpy -----
# --- model: scalar and vectorized ---
def shockley_scalar(params, t):
    a, b, g = params
    return a + b * jnp.exp(-g * t)       # scalar t -> scalar y

@jit
def shockley(params, T):
    # Broadcasted vectorized version: T can be (n,)
    a, b, g = params
    return a + b * jnp.exp(-g * T)       # vector T -> vector y

# ----- Jacobians via autodiff -----
# J_beta: dy/d[a,b,g] at each T_i  -> shape (n, 3)
@jit
def jacobian_beta(params, T):
    # grad w.r.t. params for a scalar t, then vmap over T
    g_params = grad(shockley_scalar, argnums=0)
    return vmap(g_params, in_axes=(None, 0))(params, T)

# J_x: dy/dx at each T_i            -> shape (n,)
@jit
def jacobian_x(params, T):
    g_x = grad(shockley_scalar, argnums=1)
    return vmap(g_x, in_axes=(None, 0))(params, T)

# ----- Optional: SciPy ODR adapters (shapes must match ODR's expectation) -----
# ODR expects:
#   f(beta, x)       -> (n,)
#   fjacb(beta, x)   -> (m, n)  with m = number of parameters (here 3)
#   fjacd(beta, x)   -> (1, n)
def odr_f(beta, x):
    return np.asarray(shockley(jnp.asarray(beta), jnp.asarray(x)))

def odr_fjacb(beta, x):
    # our J_beta is (n,3); transpose to (3,n) for ODR
    J = jacobian_beta(jnp.asarray(beta), jnp.asarray(x))
    return np.asarray(J.T)

def odr_fjacd(beta, x):
    # our J_x is (n,); make it (1,n) for ODR
    Jx = jacobian_x(jnp.asarray(beta), jnp.asarray(x))
    return np.asarray(Jx)[None, :]


# ------------------------------------- helpers ----------------------------------------
def pltexit():
    plt.close()
    exit()


########################################################################################
########################################################################################
########################################################################################
########################################################################################
########################################################################################
########################################################################################



# ------------------------------------- tester -----------------------------------------
tester = False
if tester:
    # print(npDV['volts'])
    print(npDV)
    exit()

# ----------------------------------- mpl config ---------------------------------------
cfg.export_final=False
cfg.configure(overrides={'lines.linewidth':0.6})


# -------------------------------------------------- main workflow -----------------------------------------------------
# get parameters for fit between pressure and voltage (Druck_Spaunung_KOrrelation.py)
# --- linear fit: Pressure = m * Voltage + b (weighted by y-errors) ---
x  = npDV['volts'].astype(float)
sx = npDV['volts_err'].astype(float)
y  = npDV['druck'].astype(float)
sy = npDV['druck_err'].astype(float)

# keep only finite points
mask =  np.isfinite(x) & np.isfinite(y) & np.isfinite(sy) & (sy > 0)
x, sx, y, sy = x[mask], sx[mask], y[mask], sy[mask]

# Weighted least squares with NumPy (weights = 1/sigma_y)
# global m,b,var_m,m_err,var_b,b_err,covar,varco
(m, b), cov = np.polyfit(x, y, deg=1, w=1.0/sy, cov=True)

odr_res =   core.odr_line(x,y,sx,sy)
xx =        np.linspace(x.min(),x.max(),512)
pp,spp =    core.odr_prediction_band(xx,odr_res['m'],odr_res['b'],odr_res['cov'])

odr_inv = core.odr_line(y,x,sy,sx)
yy=np.linspace(y.min(),y.max(),512)
vv,svv=core.odr_prediction_band(yy,odr_inv['m'],odr_inv['b'],odr_inv['cov'])

var_m = cov[0,0]
var_b = cov[1,1]
covar = cov[0,1]
varco = cov[1,0]
m_err, b_err = np.sqrt(np.diag(cov))

# for export:
slope =     m
slope_var = var_m
slope_err = m_err
offset =    b
offset_var = var_b
offset_err = b_err


# --------------------------- get preassure p_p from Up --------------------------------
m1 = Measurement.from_npz(cfg.DATA_DIR/"clean/LHJG__Supraleitung_1.npz")
print(m1.columns)

# ----- 1) Get temperature-pressure correlation from the ITS90.csv -----
T_tab_K   = ITS90_STRUCT['T_K'].astype(float)
p_tab_kPa = ITS90_STRUCT['p_kPa'].astype(float)     # ITS90.csv is in kPa -> conversion:
                                                    # 1 bar = 100000 Pa
                                                    # kPa -> bar  : multiply by 0.01
                                                    # bar -> kPa  : multiply by 100.0
p_tab_bar = p_tab_kPa * 0.01
# ----- 2) compute pressures according to linear fit -----
p,dp = linear_p_from_Up(
    Up=m1.u_p,Up_err=m1.u_p_err,
    m=odr_res['m'],dm=odr_res['sm'],
    b=odr_res['b'],db=odr_res['sb'],
    covar=odr_res['cov'][0,1],
)

# --- defining mask so interpolation doesn't look outside the table ---
tab_mask = (p>=p_tab_bar.min())&(p<=p_tab_bar.max())
U = m1.u_ab[tab_mask];  dU = m1.u_ab_err[tab_mask]
p = p[tab_mask];        dp = dp[tab_mask]
# --- separating mask for super- and normal-fluid ---
sf_mask = (p<5.207*1e-2)
nf_mask = (p>4.836*1e-2)
both = sf_mask&nf_mask
sf_only = sf_mask & ~both
nf_only = nf_mask & ~both
# --- applying the masks ---
p_sf = p[sf_mask];  dp_sf = dp[sf_mask]
p_nf = p[nf_mask];  dp_nf = dp[nf_mask]
U_sf = U[sf_mask];  dU_sf = dU[sf_mask]
U_nf = U[nf_mask];  dU_nf = dU[nf_mask]

# ----- 3) Compute Temperatures -----
Tnf_full = np.empty_like(p);    dTnf_full = np.empty_like(dp)
Tnf_full[nf_mask] = T90(p_nf, TABLEIII.HE4_nf.A0, TABLEIII.HE4_nf.Ai, TABLEIII.HE4_nf.B, TABLEIII.HE4_nf.C, units='bar', checkmate=True);   dTnf_full[nf_mask] = dT90(p_nf, dp_nf, TABLEIII.HE4_nf.A0, TABLEIII.HE4_nf.Ai, TABLEIII.HE4_nf.B, TABLEIII.HE4_nf.C, units='bar', checkmate=True)
# Tnf_full[nf_mask] = TUAB(U_nf,m,b, TABLEIII.HE4_nf.A0, TABLEIII.HE4_nf.Ai, TABLEIII.HE4_nf.B, TABLEIII.HE4_nf.C); dTnf_full[nf_mask] = dTUAB(U_nf,dU_nf,m,m_err,b,b_err, TABLEIII.HE4_nf.A0, TABLEIII.HE4_nf.Ai, TABLEIII.HE4_nf.B, TABLEIII.HE4_nf.C)

Tsf_full = np.empty_like(p);    dTsf_full = np.empty_like(dp)
Tsf_full[sf_mask] = T90(p_sf, TABLEIII.HE4_sf.A0, TABLEIII.HE4_sf.Ai, TABLEIII.HE4_sf.B, TABLEIII.HE4_sf.C, units='bar', checkmate=True);   dTsf_full[sf_mask] = dT90(p_sf, dp_sf, TABLEIII.HE4_sf.A0, TABLEIII.HE4_sf.Ai, TABLEIII.HE4_sf.B, TABLEIII.HE4_sf.C, units='bar', checkmate=True)
# Tsf_full[sf_mask] = TUAB(U_sf,m,b, TABLEIII.HE4_sf.A0, TABLEIII.HE4_sf.Ai, TABLEIII.HE4_sf.B, TABLEIII.HE4_sf.C)
# dTsf_full[sf_mask] = dTUAB(U_sf,dU_sf,m,m_err,b,b_err,TABLEIII.HE4_sf.A0, TABLEIII.HE4_sf.Ai, TABLEIII.HE4_sf.B, TABLEIII.HE4_sf.C)

# ----- 4) broadcast onto shared array -----
w_sf = np.zeros_like(p);    w_sf[sf_mask] = 1/dTsf_full[sf_mask]**2
w_nf = np.zeros_like(p);    w_nf[nf_mask] = 1/dTnf_full[nf_mask]**2
wsum = w_sf+w_nf
T = np.empty_like(p);   dT = np.empty_like(dp)
T[sf_only] = Tsf_full[sf_only];     dT[sf_only] = dTsf_full[sf_only]
T[nf_only] = Tnf_full[nf_only];     dT[nf_only] = dTnf_full[nf_only]
T[both] = (w_sf[both]*Tsf_full[both] + w_nf[both]*Tnf_full[both])/wsum[both];   dT[both] = np.sqrt(dTsf_full[both]**2 + dTnf_full[both]**2)

mask_sfit = (1.73<=T)&(T<=2.17)
mask_nfit = (T>=2.18)&(T<=4.2)
Usfit = U[mask_sfit];   dUsfit = dU[mask_sfit]
Tsfit = T[mask_sfit];   dTsfit = dT[mask_sfit]
Unfit = U[mask_nfit];   dUnfit = dU[mask_nfit]
Tnfit = T[mask_nfit];   dTnfit = dT[mask_nfit]


# -------------- 4.1) Get robust estimate for initial parameters beta0 -----------------
# IDEA: for any triplet ((x1,y1),(x2,y2),(x3,y3)) with x1<x2<x3:
# R_obs   = (y1-y2)/(y2-y3) 
#         = (a+b*exp(-g*x1) - a-b*exp(-g*x2)) / (a+b*exp(-g*x2) - a-b*exp(-g*x3))
#         = (exp(-g*x1) - exp(-g*x2)) / (exp(-g*x2) - exp(-g*x3)) \eqiv R_mod
# -> get estimate for g by minimizing |R_obs - R_mod|
# Then with fixed g:    exp(-g*x)->z, solve linear-least-squares for (a,b) from y(z) = a + b*z
def make_centered_model(T0):
    def f(beta, x):
        a, btil, c = beta
        dx = x - T0
        return a + btil * np.exp(-c * dx)

    def fjacb(beta, x):
        a, btil, c = beta
        dx = x - T0
        e = np.exp(-c * dx)
        # rows: [∂/∂a, ∂/∂b~, ∂/∂c], shape -> (3, n)
        Ja = np.ones_like(x)
        Jb = e
        Jc = -btil * dx * e
        return np.vstack([Ja, Jb, Jc])

    def fjacd(beta, x):
        a, btil, c = beta
        dx = x - T0
        e = np.exp(-c * dx)
        Jx = (-btil * c * e)[None, :]   # (1, n)
        return Jx

    return f, fjacb, fjacd

def _ratio_model(g, x1, x2, x3):
    eg1, eg2, eg3 = np.exp(-g*x1), np.exp(-g*x2), np.exp(-g*x3)
    denom = (eg2 - eg3)
    if np.abs(denom) < 1e-300:
        return np.inf
    return (eg1 - eg2) / denom

def _estimate_g_from_triple(x1, y1, x2, y2, x3, y3, g_bounds):
    # Skip degenerate cases
    denom = (y2 - y3)
    if np.abs(denom) < 1e-300:
        return np.nan
    R_obs = (y1 - y2) / denom

    def obj(g):
        R_mod = _ratio_model(g, x1, x2, x3)
        return np.abs(R_obs - R_mod)

    res = minimize_scalar(obj, bounds=g_bounds, method="bounded")
    if not res.success or not np.isfinite(res.x):
        return np.nan
    return res.x

def _pick_spread_indices(n, k):
    # choose k indices spread across [0, n-1]
    return np.unique(np.round(np.linspace(0, n-1, k)).astype(int))

# def estimate_beta0_exp_offset(x, y, n_triples=20, g_bounds=None):
#     """
#         Estimate initial [a, b, g] for y = a + b*exp(-g*x) with minimal assumptions.

#         Parameters
#         ----------
#         x, y : arrays of shape (n,)
#         n_triples : how many triples to sample across the domain (>= 3)
#         g_bounds : tuple(low, high) search bounds for g (default: auto from data span)

#         Returns
#         -------
#         beta0 : np.ndarray [a0, b0, g0]
#     """
#     x = np.asarray(x, float)
#     y = np.asarray(y, float)
#     assert x.ndim == y.ndim == 1 and x.size == y.size and x.size >= 3

#     # sort by x
#     idx = np.argsort(x)
#     x, y = x[idx], y[idx]
#     n = x.size

#     # Set a broad, data-driven search window for g:
#     #   characteristic scale ~ 1 / (x_max - x_min)
#     dx = x[-1] - x[0]
#     if dx <= 0:
#         dx = 1.0
#     if g_bounds is None:
#         # allow many decades around the characteristic scale
#         g_low  = 1e-6 / dx
#         g_high = 1e+6 / dx
#         g_bounds = (g_low, g_high)

#     # Build triples that are well spaced
#     # (e.g., pick ~sqrt(n) candidate positions and form consecutive triples)
#     k = max(5, min(n, int(np.sqrt(max(n_triples*3, 9)))))
#     pts = _pick_spread_indices(n, k)
#     triples = []
#     for i in range(len(pts)-2):
#         i1, i2, i3 = pts[i], pts[i+1], pts[i+2]
#         if i1 < i2 < i3:
#             triples.append((i1,i2,i3))

#     # If not enough, fall back to evenly spaced consecutive triples
#     if len(triples) < 3:
#         triples = [(i, i+1, i+2) for i in range(n-2)]

#     g_list = []
#     for (i1,i2,i3) in triples:
#         g_hat = _estimate_g_from_triple(x[i1], y[i1], x[i2], y[i2], x[i3], y[i3], g_bounds)
#         if np.isfinite(g_hat):
#             g_list.append(g_hat)

#     if len(g_list) == 0:
#         # fallback: simple default scale
#         g0 = 1.0 / max(dx, 1.0)
#     else:
#         # robust central estimate
#         g0 = float(np.median(g_list))

#     # With g0 fixed, solve linear least squares for a,b:
#     Phi = np.column_stack([np.ones_like(x), np.exp(-g0 * x)])  # shape (n,2)
#     ab, *_ = np.linalg.lstsq(Phi, y, rcond=None)
#     a0, b0 = ab

#     return np.array([a0, b0, g0])

# sfbeta0 = estimate_beta0_exp_offset(Tsfit,Usfit)
# nfbeta0 = estimate_beta0_exp_offset(Tnfit,Unfit)
# # OPtional: broadcast sf/nf-beta0 to curve_fit and obtain bestimate with curve_fit
# OPtional = True
# if OPtional:
#     def f_exp(x,a,b,c):
#         return a+b*np.exp(-c*x)
#     sfopt,sfcov = curve_fit(f_exp,Tsfit,Usfit,p0=sfbeta0,maxfev=10000)
#     sfbeta0 = sfopt
#     nfopt,nfcov = curve_fit(f_exp,Tnfit,Unfit,p0=nfbeta0,maxfev=10000)
#     nfbeta0 = nfopt

# model = Model(odr_f, fjacb=odr_fjacb, fjacd=odr_fjacd)

# sfdata = RealData(Tsfit, Usfit, sx=dTsfit, sy=dUsfit)
# nfdata = RealData(Tnfit, Unfit, sx=dTnfit, sy=dUnfit)

# sfout = ODR(sfdata,model,beta0=sfbeta0).run()
# nfout = ODR(nfdata,model,beta0=nfbeta0).run()

# print("sfbeta =", sfout.beta)        # [a, b, g]
# print("sfsd   =", sfout.sd_beta)     # 1σ parameter uncertainties
# print("sfwhy  =", sfout.stopreason)  # convergence info

# print("nfbeta =", nfout.beta)        # [a, b, g]
# print("nfsd   =", nfout.sd_beta)     # 1σ parameter uncertainties
# print("nfwhy  =", nfout.stopreason)  # convergence info

# -----------------------------------------------------------------------------
# def estimate_beta0_exp_offset(x, y, n_triples=20, g_bounds=None):
#     x = np.asarray(x, float)
#     y = np.asarray(y, float)
#     assert x.ndim == y.ndim == 1 and x.size == y.size and x.size >= 3

#     # sort and center
#     idx = np.argsort(x)
#     x, y = x[idx], y[idx]
#     T0 = np.median(x)
#     xc = x - T0

#     # span-based bounds for c on centered axis
#     dx = xc[-1] - xc[0]
#     dx = dx if dx > 0 else 1.0
#     if g_bounds is None:
#         g_bounds = (1e-6/dx, 1e6/dx)

#     # triples as before, but on xc
#     k = max(5, min(xc.size, int(np.sqrt(max(n_triples*3, 9)))))
#     pts = _pick_spread_indices(xc.size, k)
#     triples = [(pts[i], pts[i+1], pts[i+2]) for i in range(len(pts)-2)] or \
#               [(i, i+1, i+2) for i in range(xc.size-2)]

#     g_list = []
#     for (i1,i2,i3) in triples:
#         g_hat = _estimate_g_from_triple(xc[i1], y[i1], xc[i2], y[i2], xc[i3], y[i3], g_bounds)
#         if np.isfinite(g_hat):
#             g_list.append(g_hat)

#     g0 = float(np.median(g_list)) if len(g_list) else 1.0/max(dx, 1.0)

#     # linear least squares for a and b~ on centered axis
#     Phi = np.column_stack([np.ones_like(xc), np.exp(-g0 * xc)])
#     ab, *_ = np.linalg.lstsq(Phi, y, rcond=None)
#     a0, btil0 = ab
#     return np.array([a0, btil0, g0]), T0  # return T0 so the caller knows the centering

# (sfbeta0,sfT0) = estimate_beta0_exp_offset(Tsfit,Usfit)
# (nfbeta0,nfT0) = estimate_beta0_exp_offset(Tnfit,Unfit)

# sfmodel = Model(*make_centered_model(sfT0))
# nfmodel = Model(*make_centered_model(nfT0))

# sfdata = RealData(Tsfit,Usfit,dTsfit,dUsfit)
# nfdata = RealData(Tnfit,Unfit,dTnfit,dUnfit)

# sfout = ODR(sfdata,sfmodel,beta0=sfbeta0).run()
# nfout = ODR(nfdata,nfmodel,beta0=nfbeta0).run()

# sfa, sfbtil, sfc = sfout.beta
# nfa, nfbtil, nfc = nfout.beta
# sfb = sfbtil * np.exp(+sfc * sfT0)
# nfb = nfbtil * np.exp(+nfc * nfT0)

# print("sfbeta =", np.asarray([sfa,sfb,sfc]))        # [a, b, g]
# print("sfsd   =", sfout.sd_beta)     # 1σ parameter uncertainties
# print("sfwhy  =", sfout.stopreason)  # convergence info

# print("nfbeta =", np.asarray([nfa,nfb,nfc]))        # [a, b, g]
# print("nfsd   =", nfout.sd_beta)     # 1σ parameter uncertainties
# print("nfwhy  =", nfout.stopreason)  # convergence info

# -----------------------------------------------------------------------------
def _safe_exp_neg(g, xc):
    # Keep |g*xc| within a safe window to avoid overflow/underflow.
    # 709 ~ log(np.finfo(float).max). Use a safety margin.
    LIM = 680.0
    z = np.exp(-np.clip(g * xc, -LIM, LIM))
    return z

def estimate_beta0_exp_offset(x, y, g_bounds=None, ridge=0.0):
    """
    Robust, assumption-light initializer for y = a + b*exp(-g*x)
    Returns ( [a0, btil0, g0], T0 ) with centered x (x_c = x - T0).
    """
    x = np.asarray(x, float)
    y = np.asarray(y, float)
    assert x.ndim == y.ndim == 1 and x.size == y.size and x.size >= 3

    # sort & center
    idx = np.argsort(x)
    x, y = x[idx], y[idx]
    T0 = float(np.median(x))
    xc = x - T0
    xmax = float(np.max(np.abs(xc))) if x.size else 1.0
    dx = float(np.ptp(xc)) or 1.0

    # sensible, data-driven bounds for g
    # lower: nearly flat across span; upper: avoid overflow and absurdly steep decays
    if g_bounds is None:
        g_low  = 1e-6 / dx
        g_overflow_cap = 0.5 * 709.0 / max(xmax, 1e-12)   # keep |g*xc| <= ~354
        g_high = min(1e6 / dx, g_overflow_cap)
        g_bounds = (g_low, max(g_high, g_low*10))

    # Objective: for a given g, solve a,b~ by scaled lstsq on [1, exp(-g*xc)]
    def rss_for_g(g):
        z = _safe_exp_neg(g, xc)
        Phi = np.column_stack([np.ones_like(xc), z])

        # column scaling -> better conditioning
        col_scale = np.linalg.norm(Phi, axis=0)
        col_scale[col_scale == 0] = 1.0
        Phi_s = Phi / col_scale

        try:
            if ridge > 0:
                # (Phi_s^T Phi_s + λI) ab_s = Phi_s^T y
                ATA = Phi_s.T @ Phi_s
                ATy = Phi_s.T @ y
                ab_s = np.linalg.solve(ATA + ridge * np.eye(2), ATy)
            else:
                ab_s, *_ = np.linalg.lstsq(Phi_s, y, rcond=None)
        except np.linalg.LinAlgError:
            # tiny ridge rescue
            ATA = Phi_s.T @ Phi_s
            ATy = Phi_s.T @ y
            ab_s = np.linalg.solve(ATA + 1e-12 * np.eye(2), ATy)

        ab = ab_s / col_scale  # unscale
        res = y - Phi @ ab
        return float(res @ res)

    # 1D bounded minimization over g
    res = minimize_scalar(rss_for_g, bounds=g_bounds, method="bounded")
    g0 = float(res.x if (res.success and np.isfinite(res.x)) else 1.0 / dx)

    # final (a0, b~0) with the chosen g0
    z0 = _safe_exp_neg(g0, xc)
    Phi0 = np.column_stack([np.ones_like(xc), z0])
    col_scale = np.linalg.norm(Phi0, axis=0)
    col_scale[col_scale == 0] = 1.0
    Phi0_s = Phi0 / col_scale
    try:
        if ridge > 0:
            ATA = Phi0_s.T @ Phi0_s
            ATy = Phi0_s.T @ y
            ab_s = np.linalg.solve(ATA + ridge * np.eye(2), ATy)
        else:
            ab_s, *_ = np.linalg.lstsq(Phi0_s, y, rcond=None)
    except np.linalg.LinAlgError:
        ATA = Phi0_s.T @ Phi0_s
        ATy = Phi0_s.T @ y
        ab_s = np.linalg.solve(ATA + 1e-12 * np.eye(2), ATy)

    a0, btil0 = (ab_s / col_scale)

    return np.array([a0, btil0, g0], float), T0

# Initial parameters (separate phases)
(sfbeta0, sfT0) = estimate_beta0_exp_offset(Tsfit, Usfit)
(nfbeta0, nfT0) = estimate_beta0_exp_offset(Tnfit, Unfit)

# Centered models
sfmodel = Model(*make_centered_model(sfT0))
nfmodel = Model(*make_centered_model(nfT0))

# Ensure you pass the correct errors (x->sx, y->sy) and avoid zeros/NaNs
eps = 1e-9
dUsfit_safe = np.where(np.isfinite(dUsfit) & (dUsfit > 0), dUsfit, eps)
dUnfit_safe = np.where(np.isfinite(dUnfit) & (dUnfit > 0), dUnfit, eps)
dTsfit_safe = np.where(np.isfinite(dTsfit) & (dTsfit > 0), dTsfit, eps)
dTnfit_safe = np.where(np.isfinite(dTnfit) & (dTnfit > 0), dTnfit, eps)

sfdata = RealData(Tsfit, Usfit, sx=dTsfit_safe, sy=dUsfit_safe)
nfdata = RealData(Tnfit, Unfit, sx=dTnfit_safe, sy=dUnfit_safe)

sfout = ODR(sfdata, sfmodel, beta0=sfbeta0).run()
nfout = ODR(nfdata, nfmodel, beta0=nfbeta0).run()

# Back to original b (use the right T0 variable names)
sfa, sfbtil, sfc = sfout.beta
nfa, nfbtil, nfc = nfout.beta
sfb = sfbtil * np.exp(+sfc * sfT0)
nfb = nfbtil * np.exp(+nfc * nfT0)

print("sfbeta =", np.array([sfa, sfb, sfc]))
print("sfsd   =", sfout.sd_beta)
print("sfwhy  =", sfout.stopreason)

print("nfbeta =", np.array([nfa, nfb, nfc]))
print("nfsd   =", nfout.sd_beta)
print("nfwhy  =", nfout.stopreason)

pltexit()


if __name__=="__main__":

    initial_tests = False
    # --- some checks, from the early stages of this script ---
    if initial_tests:
        print(m)
        print(odr_res['m'])
        print(b)
        print(odr_res['b'])
        print(m_err)
        print(odr_res["sm"])
        print(b_err)
        print(odr_res['sb'])
        print(odr_res['cov'][0,1])

        show_calib=False
        if show_calib:
            calib_fig,calib_axes=plt.subplots(nrows=1,ncols=2,figsize=figrect(ncols=2))

            cal1=calib_axes[0].errorbar(x=x,xerr=sx,y=y,yerr=sy)
            calib_axes[0].plot(xx,pp,zorder=3)
            calib_axes[0].fill_between(xx,pp-spp,pp+spp,alpha=0.3,zorder=2)
            calib_axes[0].set_xlabel(rf'Voltage $U_P$ [V]')
            calib_axes[0].set_ylabel(rf'Pressure $P$ [bar]')

            cal2=calib_axes[1].errorbar(x=y,xerr=sy,y=x,yerr=sx)
            calib_axes[1].plot(yy,vv,zorder=3)
            calib_axes[1].fill_between(yy,vv-svv,vv+svv,alpha=0.3,zorder=2)
            calib_axes[1].set_ylabel(rf'Voltage $U_P$ [V]')
            calib_axes[1].set_xlabel(rf'Pressure $P$ [bar]')
            plt.show()

        print_cov = False
        if print_cov:
            label_w, val_w = 6, 24
            print('')
            print(f"{'var_m':<{label_w}}= {var_m:>{val_w}}{'':^8}"f"{'σ_m ':>{label_w}}= {np.sqrt(var_m):>{val_w}}")
            print(f"{'var_b':<{label_w}}= {var_b:>{val_w}}{'':^8}"f"{'σ_m ':>{label_w}}= {np.sqrt(var_b):>{val_w}}")
            print(f"{'covar':<{label_w}}= {var_b:>{val_w}}{'':^8}"f"{'σ_c ':>{label_w}}= {np.sqrt(var_b):>{val_w}}")
            print(f"{'varco':<{label_w}}= {var_b:>{val_w}}{'':^8}"f"{'σ_v ':>{label_w}}= {np.sqrt(var_b):>{val_w}}")
            print('')
            print(f"Fit: y = m*x + b")              # Fit: y = m*x + b
            print(f"m = {m:.6g} ± {m_err:.2g}")     # m = 1.05119 ± 0.0019
            print(f"b = {b:.6g} ± {b_err:.2g}")     # b = -0.000774967 ± 0.00013
            print(cov)

        HarryPlotter = False
        if HarryPlotter:
            fig,ax = plt.subplots(ncols=1,nrows=1,figsize=figrect())
            ax.scatter(x=npDV['volts'],y=npDV['druck'],s=1,zorder=3)
            ax.errorbar(
                x=npDV['volts'], y=npDV['druck'],
                xerr=npDV['volts_err'], yerr=npDV['druck_err'],
                fmt='none', **cfg.err_kw(),
                zorder=2
            )
            ax.set_xlabel(r"Voltage [V]")
            ax.set_ylabel(r"Pressure [bar]")
            fitboi=True
            if fitboi:
                # Optional: add fit line to your existing plot
                xx = np.linspace(x.min(), x.max(), 200)
                yy = m*xx + b
                ax.plot(
                    xx, yy,
                    lw=1.0, zorder=1, color='red',
                    label=(
                        "linear fit:\n"
                        f"m = {m:.6g} ± {m_err:.2g}\n"
                        f"b = {b:.6g} ± {b_err:.2g}"
                    ),
                )
                ax.legend()
                out_png = cfg.savefig(fig, "druck_vs_voltage_fitted", "png")
                out_pdf = cfg.savefig(fig, "druck_vs_voltage_fitted")
            else:
                out_png = cfg.savefig(fig, "druck_vs_voltage", "png")
                out_pdf = cfg.savefig(fig, "druck_vs_voltage")

            print('','Saved at', cfg.user_stripped(out_png), 'and', out_pdf, sep='\n')

            plt.show()
            # plt.close()

    show_pressure=False
    if show_pressure:
        pressure_fig,pressure_ax=plt.subplots(nrows=1,ncols=2,figsize=figrect(ncols=2))
        f1_bar=pressure_ax[0].errorbar(
            x=m1.u_p,xerr=m1.u_p_err,
            y=p_bar,yerr=dp_bar,
            **cfg.err_kw(),
        )
        f1=pressure_ax[1].errorbar(
            x=m1.u_p,xerr=m1.u_p_err,
            y=p,yerr=dp,
            **cfg.err_kw(elw=0.2,),
        )
        for bar in f1[2]:
            bar.set_alpha(0.3)
        pressure_ax[0].set_xlabel(r'Voltage $U_P$')
        pressure_ax[0].set_ylabel(r'Pressure $P$')
        plt.show()

    print(len(T))
    print(len(T[sf_only]))
    print(len(T[nf_only]))
    print(len(T[both]))
    print(f'{"Checksum:":<10}{len(T):4}=={len(T[sf_only]):>4}+{len(T[both]):4}+{len(T[nf_only]):<4}','...',bool(len(T)==len(T[sf_only])+len(T[both])+len(T[nf_only])))

    # ----- 1.1)[detour]: fit ITS90 -----
    show_c = False
    if show_c:
        cfig,cax=plt.subplots(nrows=1,ncols=1,figsize=figrect())
        c1 = cax.plot(
            p_tab_bar,T_tab_K,
            label=r'ITS90-calibration',
        )
        xx = np.linspace(p_tab_bar.min(),p_tab_bar.max(),1024)
        whole_range = True
        if whole_range:     xxHE3=xx;   xxHE4sf=xx;     xxHE4nf=xx
        else:
            xxHE3 =     np.linspace(TABLEIII.HE3.valid_p[0], TABLEIII.HE3.valid_p[1],512)*1e-2
            xxHE4sf =   np.linspace(TABLEIII.HE4_sf.valid_p[0], TABLEIII.HE4_sf.valid_p[1],512)*1e-2
            xxHE4nf =   np.linspace(TABLEIII.HE4_nf.valid_p[0], TABLEIII.HE4_nf.valid_p[1],512)*1e-2

        # yyHE3 =     T90(xxHE3, TABLEIII.HE3.A0, TABLEIII.HE3.Ai, TABLEIII.HE3.B, TABLEIII.HE3.C, units='bar', checkmate=True)
        # c2 =        cax.plot(xx,yyHE3,  label=r'$T_{90}$ for $^{3}$HE')
        yyHE4sf =   T90(xxHE4sf, TABLEIII.HE4_sf.A0, TABLEIII.HE4_sf.Ai, TABLEIII.HE4_sf.B, TABLEIII.HE4_sf.C, units='bar', checkmate=True)
        c3 =        cax.plot(xx,yyHE4sf,label=r'$T_{90}$ for $^{4}$HE - superfluid')
        yyHE4nf =   T90(xxHE4nf, TABLEIII.HE4_nf.A0, TABLEIII.HE4_nf.Ai, TABLEIII.HE4_nf.B, TABLEIII.HE4_nf.C, units='bar', checkmate=True)
        c4 =        cax.plot(xx,yyHE4nf,label=r'$T_{90}$ for $^{3}$HE - normalfluid')

        cax.set_ylim(1.0,T_tab_K.max())
        cax.set_xlabel(r'Pressure $P\quad[\mathrm{bar}]$')
        cax.set_ylabel(r'Temperature $T\quad[\mathrm{K}]$')
        cax.legend()
        plt.show()

    # --- figure of pressure p and voltage U_AB over temperature T ---
    show_d=False
    if show_d:
        dfig,dax = plt.subplots(ncols=1,nrows=1,figsize=figrect())
        dsecax = dax.twinx()
        d1 = dax.errorbar(x=Tsf,y=p_sf,yerr=dp_sf,label=r'$T_{90}$ superfluid')
        d2 = dax.errorbar(x=Tnf,y=p_nf,yerr=dp_nf,label=r'$T_{90}$ normalfluid')
        dsec1 = dsecax.errorbar(x=T,y=U,yerr=dU,label=r'Voltage $U_\mathrm{AB}$')
        # labels = [dax.get_labels(),dsexax.get_labels()]
        # handles = [dax.get_handles(),dsecax.get_handles()]
        dax.legend()
        # dax.set_xlim(2.0,2.35)
        # dax.set_ylim(0.0,0.1)
        dax.set_xlabel(r'Temperature $T\quad[\mathrm{K}]$')
        dax.set_ylabel(r'Pressure $P(U_\mathrm{P})\quad[\mathrm{bar}]$')
        dsecax.set_ylabel(r'Voltage $U_\mathrm{AB}\quad[\mathrm{V}]$')
        plt.show()
        pltexit()

    # --- figure of temperature over U_AB ---
    show_e = False
    if show_e:
        efig,eax = plt.subplots(ncols=1,nrows=1,figsize=figrect())
        e1 = eax.errorbar(x=U,xerr=dU,y=T,yerr=dT)
        eax.set_xlabel(r"Voltage [V]")
        plt.show()
        pltexit()

    # # ------------------------ Allen-Bradley Calibration -------------------------------
    # if not cfg.confirm():   pltexit()
    # # --- defining masks for super-fluid and normal-fluid phases (and additional) ---
    # mask_infty = np.isfinite(T) & np.isfinite(dT) & np.isfinite(U) & np.isfinite(dU)
    # mask0 = (T<=4.2)
    # mask_zoom = (1.73<=T)&(T<=2.2)
    # mask_normalfluid = (2.2<=T)&(T<=4.2)
    # mask_superfluid = (T>=1.78)&(T<=2.15) 
    # # mask_superfluid = ((2.07<=T)&(2.15>=T))     # there is a little secondary (smaller bump at approx 2.05)
    # mask = mask_infty&mask0
    # # --- apply masks ---
    # T_sf, U_sf, sU_sf = T[mask_superfluid],  U[mask_superfluid],  dU[mask_superfluid]
    # T_nf, U_nf, sU_nf = T[mask_normalfluid], U[mask_normalfluid], dU[mask_normalfluid]
    # # --- special treatment for the errors in T ---
    # if dT_method == 'asym': sT_sf = dT[:,mask_superfluid];  sT_nf = dT[:,mask_normalfluid]
    # else:                   sT_sf = dT[mask_superfluid];    sT_nf = dT[mask_normalfluid]
    # # ODR need symmetric errors:
    # sT_sf = np.maximum(sT_sf[0,:],sT_sf[1,:]);  sT_nf = np.maximum(sT_nf[0,:],sT_nf[1,:])

    # init_params_sf = guess_params(T_sf,U_sf,log_slope=True);   init_params_nf = guess_params(T_nf,U_nf)

    # shockley_model = Model(
    #     fcn=lambda beta, x: mdl_shockley(beta, x),
    #     fjacb=mdl_jacobean_params,
    #     fjacd=mdl_jacobean_variables
    # )
    # data_sf = RealData(x=T_sf,y=U_sf,sx=sT_sf,sy=sU_sf);    data_nf = RealData(x=T_nf,y=U_nf,sx=sT_nf,sy=sU_nf)
    # odr_sf = odr.ODR(data_sf,shockley_model,beta0=init_params_sf,maxit=300)
    # odr_nf = odr.ODR(data_nf,shockley_model,beta0=init_params_nf,maxit=300)
    # out_sf = odr_sf.run();  out_nf = odr_nf.run()

    # asf,bsf,gsf = out_sf.beta;          anf,bnf,gnf = out_nf.beta
    # sasf,sbsf,sgsf = out_sf.sd_beta;    sanf,sbnf,sgnf = out_nf.sd_beta
    # cov_sf = out_sf.cov_beta;           cov_nf = out_nf.cov_beta
    # res_var_sf = out_sf.res_var;        res_var_nf = out_nf.res_var

    # print('Scipy.Optimize.Curve_Fit:')
    # cf_best_sf,cf_cov_sf = curve_fit(
    #     lambda T,a,b,g: a+b*np.exp(-g*T),
    #     T_sf,U_sf,
    #     )
    # cf_best_nf,cf_cov_nf = curve_fit(
    #     lambda T,a,b,g: a+b*np.exp(-g*T),
    #     T_nf,U_nf,
    #     )

    plot_AB=True
    if plot_AB:
        fig,ax=plt.subplots(nrows=1,ncols=2,figsize=figrect(ncols=2))

        sfxx = np.linspace(T[mask_zoom].min(),T[mask_zoom].max(),512)
        sfyy = mdl_shockley(out_sf.beta,sfxx)
        sfcf = mdl_shockley(cf_best_sf,sfxx)
        ax[0].errorbar(x=T[mask_zoom],xerr=dT[:,mask_zoom],y=U[mask_zoom],yerr=dU[mask_zoom])
        ax[0].set_title(r'Superfuid Phase')
        ax[0].set_xlabel(r'Temperatur [K]')
        ax[0].set_ylabel(r'Spannung $U_\mathrm{AB}$')
        ax[0].plot(sfxx,sfyy,zorder=3)
        ax[0].plot(sfxx,sfcf,zorder=3)

        nfxx = np.linspace(T_nf.min(),T_nf.max(),512)
        nfyy = mdl_shockley(out_nf.beta,nfxx)
        nfcf = mdl_shockley(cf_best_nf,nfxx)
        ax[1].errorbar(x=T_nf,xerr=sT_nf,y=U_nf,yerr=sU_nf)
        ax[1].set_title(r'Normalfluid Phase')
        ax[1].set_xlabel(r'Temperatur [K]')
        ax[1].set_ylabel(r'Spannung $U_\mathrm{AB}$')
        ax[1].plot(nfxx,nfyy,zorder=3)
        ax[1].plot(nfxx,nfcf,zorder=3)

        plt.show()

    pltexit()